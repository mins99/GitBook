---
description: '이 글은 ''Clean Code'' (저자 로버트 C. 마틴, 역자 박재호, 이해영)'' 책 내용 중 일부를 정리한 글입니다.'
---

# 3장 함수

 `프로그램의 가장 기본적인 단위인 함수를 잘 만드는 법`

### **작게 만들어라!**

* 함수를 만드는 첫째 규칙은 '작게!', 둘째 규칙은 '더 작게!'
* 블록과 들여쓰기
  * if 문/else 문/while 문 등에 들어가는 블록은 한 줄에 가까우면 좋다
  * 블록 안에서 함수를 호출하면 바깥을 감싸는 함수가 작아지고, 함수명을 적절히 지으면 코드를 이해하기 쉬워짐
  * 함수의 들여쓰기 수준을 1단에서 2단으로 해야 이해하기 쉬워짐

### 한 가지만 해라!

* **함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**
* 개선한 코드의 추상화 수준은 하나라고 할 수 있다\(page 43\)
  * 페이지가 테스트 페이지인지 확인 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣고\(이건 includeSetupAndTeardownPages 메소드로 호출\), 테스트 페이지든 아니든 페이지를 HTML로 렌더링 한다\(renderPageWithSetupsAndTeardowns\)
* 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다
* 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서임
* 단순히 다른 표현이 아닌 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러가지 작업을 한다고 볼 수 있다

### 함수 당 추상화 수준은 하나로!

* 함수가 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 함
* 추상화 수준 비교
  * getHtml\(\)은 추상화 수준이 아주 높음
  * String pagePathName = PathParser.render\(pagepath\); 는 중간
  * .append\("\n"\)는 추상화 수준이 아주 낮다
* 한 함수 내에 추상화 수준을 섞으면 이해하기 힘들다
* 위에서 아래로 코드 읽기 : 내려가기 규칙
  * 위에서 아래로 코드를 읽으면 함수 추상화 수준이 한 번에 한 단계식 낮아지도록
  * 핵심은 짧으면서도 '한 가지'만 하는 함수

### Switch 문

* 본질적으로 switch문은 N가지를 처리하고, switch를 완전히 피하기도 어렵다
* 다형성을 이용하여 switch문을 저차원 클래스에 숨기고 반복하지 않기
  * 인터페이스\(EmployeeFactory\) 생성 후 구현 클래스에서 switch문을 생성하여 적절한 함수가 호출될 수 있도록 하기

### 서술적인 이름을 사용하라!

* "코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드"와 더불어 길고 서술적인 이름이 짧고 어려운 이름보다 좋다
* 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용\(일관성 있게\)

### 함수 인수

* 이상적인 인수 개수는 0개 : 인수가 있으면 코드를 읽는 사람이 인수를 해석해야 함
* 단항 형식 : 인수에 질문을 던지거나 인수를 변환하여 결과를 반환하는 경우 사용
* 플래그 인수 : 인수로 boolean 타입은 좋지 않다. 
* 이항 함수 : 인수 2개가 한 값을 표현하고 자연적인 순서가 있을 때 사용 
  * Point p = new Point\(0, 0\) 과 같은 좌표의 경우 인수가 두 개이지만 한 값을 표현하는 두 요소이며 자연적인 순서가 있음
  * writeField\(outputStream, name\) 과 같은 함수는 outputSteam.writeField\(name\)과 같은 방법으로 하는 것이 좋다
* 삼항 함수 : 인수가 많을 수록 이해하기 어려우므로 만들게 되면 신중히 고려하기를 권고
* 인수 객체 : 객체로 묶는다 해도 묶은 객체의 이름을 붙이게 되면 그 객체를 이해해야 한다
* 동사와 키워드 : 단항 함수는 함수와 인수가 동사/명사 쌍을 이루도록 하고, 함수 이름에 인수 이름과 같은 키워드를 추가하면 좋다\(assertEquals 보다 assertExpectedEqualsActual\(expected, actual\)\)

### 부수 효과를 일으키지 마라!

* 함수에서 한 가지를 하겠다고 했으면 한 가지만 하도록
* 클래스 변수를 수정하거나 인수나 전역 변수를 수정하지 않도록 한다
* 시간적인 결합이나 순서 종속성을 초래하게 된다
* checkPassword 라는 함수에서 어떤 조건을 만족하면 세션을 초기화하는 부수 효과 -&gt; 의도하지 않게 세션 정보를 초기화할 수 있음
  * 이 경우 checkPasswordAndInitializeSession 이란 이름이 나음\(두 가지 일을 하기는 해도\)
* 출력 인수 : StringBuffer와 같은 출력을 하는 변수는 인수로 부적절. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 것이 좋다

### 명령과 조회를 분리하라!

* 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 함\(객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나\)

```text
if(set("username", "unclebob")) 보다는
if(attributeExists("username")) { setAttribute("username", "unclebob"); }
```

### 오류 코드보다 예외를 사용하라!

* 명령 함수에서 오류 코드를 반환하는 것은 명령/조회 분리 규칙을 미묘하게 위반할 수 있다
  * if문에서 명령을 표현식으로 사용\(if\(deletePage\(page\) == E\_OK\)\) -&gt; 오류 코드를 곧바로 처리해야 하는 문제
* 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해짐
* try/catch 블록 : 정상 동작과 오류 처리 동작을 분리하면 이해하고 수정하기 쉬워짐
* 오류를 처리하는 함수는 오류 처리라는 '한 가지' 작업만 하도록 해야한다.
* 오류 코드를 반환하는 것은 클래스나 열거형 변수 등을 통해 오류 코드를 정의했다는 것이고 값을 변경하기 힘든 문제가 있다.

### 구조적 프로그래밍

* 함수가 클 때는 함수 내 모든 블록에 입구와 출구가 하나만 존재하도록 하는 것이 좋지만
* 함수가 작을 때는 하나만 존재하는 것이 별 이익을 제공하지 못하므로 return, break, continue를 여러 차례 사용해도 괜찮다

### 함수를 어떻게 짜죠?

* 처음에는 길고 복잡하지만 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거하고, 메서드를 줄이고, 순서를 바꾸고, 전체 클래스를 쪼개는 작업을 통해 단순하게 만들 수 있다

